import{_ as e,c as t,o as a,U as r}from"./chunks/framework.fNqm3e01.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/前端知识/代理.md","filePath":"docs/前端知识/代理.md","lastUpdated":1704357645000}'),o={name:"docs/前端知识/代理.md"},s=r('<p>代理就相当于中间商,本来A和B是可以直接连接的,但是此时添加了一个C在中间,A跟B不直接连接,而是通过C作为中介进行连接。<br>一个完整的请求是由: client(客户端) -&gt; proxy(代理) -&gt; server(服务端) 组成。</p><h3 id="正向代理" tabindex="-1">正向代理 <a class="header-anchor" href="#正向代理" aria-label="Permalink to &quot;正向代理&quot;">​</a></h3><p>顺着请求的方向进行的代理，即代理服务器它是由你配置为你服务，去请求目标服务器地址。<br>以访问谷歌为例，由于某些原因，目前无法直接访问到谷歌，我们可以通过连接一台代理服务器,代理服务将我们的请求提交到谷歌,然后再将谷歌的响应反馈给我们,对于谷歌而言,它只知道有一个请求过来,但是它并不会知道我们是无法直接访问它的。<br>正向代理就是平时所说的翻墙工具。</p><h3 id="反向代理" tabindex="-1">反向代理 <a class="header-anchor" href="#反向代理" aria-label="Permalink to &quot;反向代理&quot;">​</a></h3><p>为目标服务器进行服务的。<br>但是请求的流程还是: client -&gt; proxy -&gt; server。<br>以打客服电话为例，打的这个电话是该机构的总线，最终会分配给具体某位客服来处理，这个时候总线就是我们的「反向代理」，它的作用体现在当有 100 个人同时打进总线的时候，能够合理的分配空闲的客服来对接，这也是负载均衡的概念。</p>',5),_=[s];function c(n,d,i,l,p,h){return a(),t("div",null,_)}const b=e(o,[["render",c]]);export{f as __pageData,b as default};
