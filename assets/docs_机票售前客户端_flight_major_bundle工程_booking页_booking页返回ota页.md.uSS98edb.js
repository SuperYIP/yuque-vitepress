import{_ as a,o as s,c as i,R as e}from"./chunks/framework.3LEfkZv-.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/机票售前客户端/flight_major_bundle工程/booking页/booking页返回ota页.md","filePath":"docs/机票售前客户端/flight_major_bundle工程/booking页/booking页返回ota页.md","lastUpdated":1702735874000}'),l={name:"docs/机票售前客户端/flight_major_bundle工程/booking页/booking页返回ota页.md"},o=e(`<h2 id="返回拦截逻辑" tabindex="-1">返回拦截逻辑 <a class="header-anchor" href="#返回拦截逻辑" aria-label="Permalink to &quot;返回拦截逻辑&quot;">​</a></h2><p>booking页返回ota页做了拦截操作，可拦截adr和ios的点击返回按钮返回、adr左滑返回，但是拦截不了ios左滑返回(谁都拦不了)。返回操作实际是通过执行<code>Ext.close()</code>方法实现的，所以拦截返回的逻辑是在执行Ext.close()前做些条件判断是否执行Ext.close()进行返回操作，不执行就是拦截了呗。</p><h3 id="返回时实际调用的方法" tabindex="-1">返回时实际调用的方法 <a class="header-anchor" href="#返回时实际调用的方法" aria-label="Permalink to &quot;返回时实际调用的方法&quot;">​</a></h3><h4 id="返回按钮-adr、ios都一样-navigationbar中的onbackpress-方法-然后调用orderfillstore中的onbackpressed-方法。" tabindex="-1">返回按钮（adr、ios都一样）：NavigationBar中的onBackPress()方法，然后调用OrderFillStore中的onBackPressed()方法。 <a class="header-anchor" href="#返回按钮-adr、ios都一样-navigationbar中的onbackpress-方法-然后调用orderfillstore中的onbackpressed-方法。" aria-label="Permalink to &quot;返回按钮（adr、ios都一样）：NavigationBar中的onBackPress()方法，然后调用OrderFillStore中的onBackPressed()方法。&quot;">​</a></h4><h4 id="adr左滑-orderfillview中的onbackpressed-方法-然后调用orderfillstore中的onbackpressed-方法。" tabindex="-1">adr左滑：OrderFillView中的onBackPressed()方法，然后调用OrderFillStore中的onBackPressed()方法。 <a class="header-anchor" href="#adr左滑-orderfillview中的onbackpressed-方法-然后调用orderfillstore中的onbackpressed-方法。" aria-label="Permalink to &quot;adr左滑：OrderFillView中的onBackPressed()方法，然后调用OrderFillStore中的onBackPressed()方法。&quot;">​</a></h4><p>QView默认支持了安卓物理键返回的监听，这个onBackPressed()方法使用时类似生命周期函数，只要声明了，在执行到对应操作时就会默认调用。</p><h4 id="总结-上述的返回方式-最后调用的都是rollbackmodel中的requestrollback-方法-用于判断是否真正阻断用户返回。" tabindex="-1">总结：上述的返回方式，最后调用的都是RollbackModel中的requestRollback()方法，用于判断是否真正阻断用户返回。 <a class="header-anchor" href="#总结-上述的返回方式-最后调用的都是rollbackmodel中的requestrollback-方法-用于判断是否真正阻断用户返回。" aria-label="Permalink to &quot;总结：上述的返回方式，最后调用的都是RollbackModel中的requestRollback()方法，用于判断是否真正阻断用户返回。&quot;">​</a></h4><h3 id="定义拦截逻辑的方法rollbackmodel中的requestrollback" tabindex="-1">定义拦截逻辑的方法RollbackModel中的requestRollback() <a class="header-anchor" href="#定义拦截逻辑的方法rollbackmodel中的requestrollback" aria-label="Permalink to &quot;定义拦截逻辑的方法RollbackModel中的requestRollback()&quot;">​</a></h3><p>在这个方法中定义了拦截的一些逻辑。执行返回操作就会调用这个方法，判断是否需要进行拦截。</p><h4 id="首先判断是否请求f-flight-roll-back-new接口获取弹窗数据" tabindex="-1">首先判断是否请求<code>f_flight_roll_back_new</code>接口获取弹窗数据 <a class="header-anchor" href="#首先判断是否请求f-flight-roll-back-new接口获取弹窗数据" aria-label="Permalink to &quot;首先判断是否请求\`f_flight_roll_back_new\`接口获取弹窗数据&quot;">​</a></h4><p>请求接口的前置条件</p><div class="language-tsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">isLogin </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 已登陆</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bookingInValidTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 还在booking有效期内，过期需要刷新booking页</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ArrayUtils.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(addedPassengers) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 勾选了乘机人</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rollBackSwitch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rollBackWaitTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 在booking页停留了指定时间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">notBuyInsAndX </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">showRePushQuote </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.viaRollbackToExtraCarPageThenBack</span></span></code></pre></div><h4 id="其次判断f-flight-roll-back-new弹窗接口是否返回了弹窗数据" tabindex="-1">其次判断<code>f_flight_roll_back_new</code>弹窗接口是否返回了弹窗数据 <a class="header-anchor" href="#其次判断f-flight-roll-back-new弹窗接口是否返回了弹窗数据" aria-label="Permalink to &quot;其次判断\`f_flight_roll_back_new\`弹窗接口是否返回了弹窗数据&quot;">​</a></h4><p>返回时会通过RollbackCmp（这个Cmp是定义在module_search库中的）中的fetchRollback()方法请求：<code>f_flight_roll_back_new</code>接口，返回了弹窗信息则拦截，否则不拦截。</p><h3 id="校验当天内是否展示过弹窗-在orderfillstore中定义的方法和属性" tabindex="-1">校验当天内是否展示过弹窗（在OrderFillStore中定义的方法和属性） <a class="header-anchor" href="#校验当天内是否展示过弹窗-在orderfillstore中定义的方法和属性" aria-label="Permalink to &quot;校验当天内是否展示过弹窗（在OrderFillStore中定义的方法和属性）&quot;">​</a></h3><p>通过<code>todayIsShowDetainCouponAlert</code>属性做判断，为<code>true</code>表示展示过了。通过<code>getLastShowDetainCouponTime()</code>方法判断今天是否展示过弹窗，从而改变<code>todayIsShowDetainCouponAlert</code>属性的值。在初始化OrderFillStore时去调用<code>getLastShowDetainCouponTime()</code>方法。</p>`,16),t=[o];function r(n,h,d,k,c,p){return s(),i("div",null,t)}const _=a(l,[["render",r]]);export{g as __pageData,_ as default};
