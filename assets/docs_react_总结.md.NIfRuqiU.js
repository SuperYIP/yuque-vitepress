import{_ as s,o as a,c as i,R as n}from"./chunks/framework.3LEfkZv-.js";const t="/assets/c8b805b02ec621de3bd66ebf60eeceb1.BjbOFFtp.png",e="/assets/f0f5331412d9cf9ab530c9030dae2c19.TzM2l-na.png",y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/react/总结.md","filePath":"docs/react/总结.md","lastUpdated":1702735041000}'),l={name:"docs/react/总结.md"},p=n(`<h2 id="一-工程方面" tabindex="-1">一. 工程方面 <a class="header-anchor" href="#一-工程方面" aria-label="Permalink to &quot;一. 工程方面&quot;">​</a></h2><h3 id="工程结构" tabindex="-1">工程结构 <a class="header-anchor" href="#工程结构" aria-label="Permalink to &quot;工程结构&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">├── </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">README</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.md</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">├── </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lock.json</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">├── package.json</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">├── public</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── favicon.ico</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── index.html</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── logo192.png</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── logo512.png</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── manifest.json</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   └── robots.txt</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">├── src</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── App.css</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── App.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── App.test.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── components				</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 存放其他页面组件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── index.css</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── index.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── logo.svg</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── reportWebVitals.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── router						</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 存放路由文件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   │   └── IndexRouter.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── setupProxy.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── setupTests.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   └── views							</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 存放和路由相关的页面组件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">└── tree.txt</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> directories, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> files</span></span></code></pre></div><h3 id="react修改默认启动端口" tabindex="-1">react修改默认启动端口 <a class="header-anchor" href="#react修改默认启动端口" aria-label="Permalink to &quot;react修改默认启动端口&quot;">​</a></h3><blockquote><p><a href="https://blog.csdn.net/weixin_69903461/article/details/131353700?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-131353700-blog-121686974.235%5Ev38%5Epc_relevant_sort_base3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-131353700-blog-121686974.235%5Ev38%5Epc_relevant_sort_base3&amp;utm_relevant_index=5" target="_blank" rel="noreferrer">https://blog.csdn.net/weixin_69903461/article/details/131353700?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-131353700-blog-121686974.235%5Ev38%5Epc_relevant_sort_base3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-131353700-blog-121686974.235%5Ev38%5Epc_relevant_sort_base3&amp;utm_relevant_index=5</a></p></blockquote><p>node_modules -&gt; react-script -&gt; scripts -&gt; start.js文件 -&gt; DEFAULT_PORT变量<br><img src="`+t+'" alt="image.png"></p><h4 id="使用vite创建的项目修改默认端口" tabindex="-1">使用vite创建的项目修改默认端口 <a class="header-anchor" href="#使用vite创建的项目修改默认端口" aria-label="Permalink to &quot;使用vite创建的项目修改默认端口&quot;">​</a></h4><p>在package.json -&gt; scripts -&gt; dev中加入 <code>--port</code> 参数即可修改默认启动端口，加入<code>--open</code>参数可以在执行<code>npm run dev</code>启动项目后，自动打开页面。<br><img src="'+e+`" alt="image.png"></p><h3 id="配置可以使用-符号作为路径引入文件" tabindex="-1">配置可以使用@符号作为路径引入文件 <a class="header-anchor" href="#配置可以使用-符号作为路径引入文件" aria-label="Permalink to &quot;配置可以使用@符号作为路径引入文件&quot;">​</a></h3><h4 id="在vite-config-ts中添加配置" tabindex="-1">在vite.config.ts中添加配置 <a class="header-anchor" href="#在vite-config-ts中添加配置" aria-label="Permalink to &quot;在vite.config.ts中添加配置&quot;">​</a></h4><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 引入path模块</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;path&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  plugins: [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">react</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  resolve: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 定义@符号的别名，此时@符号就相当于src路径</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    alias: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &quot;@&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__dirname, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./src&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h4 id="安装关于node库的ts声明配置" tabindex="-1">安装关于node库的ts声明配置 <a class="header-anchor" href="#安装关于node库的ts声明配置" aria-label="Permalink to &quot;安装关于node库的ts声明配置&quot;">​</a></h4><p>上一步引入path模块会有红线提示，说明ts没有识别到node库。<br>终端执行：<code>npm i -D @types/node</code></p><h4 id="增加输入-符号后的路径提示" tabindex="-1">增加输入@ 符号后的路径提示 <a class="header-anchor" href="#增加输入-符号后的路径提示" aria-label="Permalink to &quot;增加输入@ 符号后的路径提示&quot;">​</a></h4><p>执行完上述两步后已经可以通过<code>import &#39;@/global.scss&#39;</code>引入模块了，但是在输入@ 符号后没有路径提示。<br>解决方式：在tsconfig.json中添加配置：，在<code>compilerOptions</code>中添加<code>baseUrl</code>和<code>path</code>字段。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;compilerOptions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;baseUrl&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;paths&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            &quot;@/*&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                &quot;src/*&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="二-语法方面" tabindex="-1">二. 语法方面 <a class="header-anchor" href="#二-语法方面" aria-label="Permalink to &quot;二. 语法方面&quot;">​</a></h2><h3 id="setstate是同步还是异步" tabindex="-1"><strong>setState是同步还是异步</strong> <a class="header-anchor" href="#setstate是同步还是异步" aria-label="Permalink to &quot;**setState是同步还是异步**&quot;">​</a></h3><p>结论：在同步代码中，setState()异步执行，在异步函数中，setState()同步执行。在react18中，所有位置，setState()都是异步执行的了。</p><blockquote><p>参考： <a href="https://www.bilibili.com/video/BV1yb4y1i7rP/?spm_id_from=333.337.search-card.all.click&amp;vd_source=d2ee6de80aecd10f87a2ffa4e6eea5b8" target="_blank" rel="noreferrer">https://www.bilibili.com/video/BV1yb4y1i7rP/?spm_id_from=333.337.search-card.all.click&amp;vd_source=d2ee6de80aecd10f87a2ffa4e6eea5b8</a></p></blockquote><h3 id="render-什么时候会重新执行" tabindex="-1">render()什么时候会重新执行 <a class="header-anchor" href="#render-什么时候会重新执行" aria-label="Permalink to &quot;render()什么时候会重新执行&quot;">​</a></h3><p>组件的state改变（执行setState()时）和props改变时（父组件传递过来的值或者store里的值改变时），render()会重新执行</p><h3 id="constructor-只会在组件初始化时执行一次-render-重新执行时-constructor-不会重新执行的" tabindex="-1">constructor()只会在组件初始化时执行一次，render()重新执行时，constructor()不会重新执行的 <a class="header-anchor" href="#constructor-只会在组件初始化时执行一次-render-重新执行时-constructor-不会重新执行的" aria-label="Permalink to &quot;constructor()只会在组件初始化时执行一次，render()重新执行时，constructor()不会重新执行的&quot;">​</a></h3>`,23),h=[p];function r(k,o,c,d,E,g){return a(),i("div",null,h)}const b=s(l,[["render",r]]);export{y as __pageData,b as default};
