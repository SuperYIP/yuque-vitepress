1.  需求背景和原因<br />针对重复搜索航线的用户，在list页弹出浮窗扩展触达的途径，以进一步提升用户转化。 
2.  需求重点<br />动画<br />组件复用性<br />业务逻辑 
3.  动画<br />移动<br />淡入淡出<br />吸底 

移动：组件出现和消失时的由下到上、由上到下的移动动画<br />淡入淡出：在组件出现和消失的移动过程中有淡入淡出效果<br />吸底：在list页滑动时，组件要跟随移动并吸附到页面底部<br />constructor(props: IProps) {<br />super(props);<br />this.slideAnimation = new Animated.Value(0);<br />this.slideInAnimation = this.slideAnimation;<br />this.opacityAnimation = this.slideAnimation;<br />};

Animated.timing(this.slideAnimation, {<br />toValue: 1,<br />// 动画持续时间，毫秒<br />duration: 300,<br />easing: Easing.linear,<br />useNativeDriver: true,<br />}).start();

<Animated.View<br />style={[<br />styles.container,<br />{<br />transform: [{<br />translateY: this.slideInAnimation.interpolate({<br />inputRange: [0, 1],<br />outputRange: [isIphoneX ? 103 : parseInt(tipHeight), 0],<br />})<br />}], opacity: this.opacityAnimation<br />},<br />this.props.viewMarginBottom && { bottom: this.props.viewMarginBottom },



移动和淡入淡出效果是同步进行的，所以两个动画对象引用同一个Animated对象，分别加到组件的translateY和opacity属性上实现移动和淡入淡出效果。这里需要注意的是透明度的范围是0-1，而组件移动的距离是0-96，所以需要通过interpolate插值将组件的移动距离由0-1映射到103-0。

outputRange: [103, 0]为什么组件的移动方向是从103开始到0？<br />原因是这个浮窗组件是绝对定位，距离页面底部的距离由bottom属性控制，组件挂载时浮窗bottom属性值是103，也就是浮窗的出现动画应该是让组件从下方距离自身103距离的位置移动到组件的初始位置0，所以outputRange是从103到0。

translateY规律（设组件初始位置为0）：表示元素相对于其正常位置垂直方向上的位移<br />正数在组件下方，负数在组件上方。

例：[103, -103]表示组件从正常位置下方103位置移动到组件上方103位置。

这里需要跑代码展示一下。

为什么组件挂载时浮窗bottom属性值是103？<br />因为浮窗有吸底功能，浮窗距离底部的高度由viewMarginBottom属性控制，viewMarginBottom值为103时浮窗处于正常展示位置，viewMarginBottom值为10时浮窗吸底展示。所以浮窗组件展示时bottom值只能为103或者10，没有办法是0，而浮窗关闭时需要在界面中消失(bottom值为0)，那就只能让浮窗初始高度为103。

吸底动画这里需要在list页列表组件的onScroll方法中监测列表滚动距离，计算滚动距离大于50的时候，浮窗组件就要执行吸底动画。（这个吸底动画的逻辑和浮窗组件消失的逻辑是一样的，只不过吸底不是移动到了视图范围之外，而是视图的底部）

onScroll = (event: any) => {<br />let contentOffsetY = (event && event.nativeEvent && event.nativeEvent.contentOffset && event.nativeEvent.contentOffset.y) || 0;<br />this.setBottomVisibility(contentOffsetY);<br />}<br />setBottomVisibility(endY) {<br />// 手指从上往下划<br />if (this.beginY - endY > 50 && this.state.bottomShow === false) {<br />this.showBottomView(true);<br />this.beginY = endY;<br />} else if (endY - this.beginY > 50 && this.state.bottomShow === true) {<br />this.showBottomView(false);<br />this.beginY = endY;<br />}<br />}<br />showBottomView(show: boolean) {<br />this.setState({<br />bottomShow: show<br />});<br />// 底部提示条的显隐，跟随底部栏<br />this.props.store?.lowPriceRemindModel?.setBottomTipShow(show);<br />}

// 控制底部提示条的显隐，滑动吸附效果<br />[@action.bound ](/action.bound ) setBottomTipShow(show: boolean) { <br />const bottomViewShow = this.viewMarginBottom === this.tipHeight ? true : false;<br />if (bottomViewShow !== show) {<br />LayoutAnimation.configureNext({<br />duration: 300,<br />create: {<br />type: LayoutAnimation.Types.easeInEaseOut,<br />property: LayoutAnimation.Properties.opacity<br />},<br />update: {<br />type: LayoutAnimation.Types.easeInEaseOut<br />}<br />});<br />if (show) {<br />this.viewMarginBottom = this.tipHeight;<br />} else {<br />this.viewMarginBottom = 10;<br />}<br />}<br />}<br />4. 组件复用性<br />伊海迪 > 2023-12-19：低价订阅需求分享 > image-2023-12-17_21-7-2.png

伊海迪 > 2023-12-19：低价订阅需求分享 > image-2023-12-17_21-7-10.png

组件复用性可以体现在样式上的复用性和交互上的复用性。

样式上的复用性主要考虑组件的哪些部分可能会变。总结得出：组件背景色、图片、主副标题和按钮部分。<br />图片位置除了图片内容可以替换外，设计了动图加载逻辑：首先渲染静态图，通过Image组件的onLoad事件监听动图的加载情况，若拿到了动图的宽高值则说明动图加载成功，将静态图替换为动图。这样可以避免直接加载动图时图片位置由于动图还没有加载好而没有任何展示内容的情况。

{/_ 左侧动图 _/}

<Image<br />onLoadEnd={() => {<br />this.onLoadAction && this.setState({<br />...this.state,<br />showGif: true<br />});<br />}}<br />source={{ uri: flashIcon }}<br />onLoad={(evt: any) => {<br />const { width, height } = evt?.nativeEvent?.source || {};<br />if (width && height) {<br />this.onLoadAction = true<br />}<br />}}<br />style={styles.priceReminderImage} /><br />{!this.state.showGif ?<br /><Image<br />style={styles.priceReminderImage}<br />source={{ uri: icon }}<br />/> : null}<br />主副标题部分由于文案中需要特殊颜色文字的位置可能不固定，所以使用富文本的方式进行配置，通过HtmlText组件渲染富文本使得整个文案任意文字需要特殊颜色都可配置实现。

<HtmlText style={[styles.subTitleText, { fontSize: parseInt(subTitle.fontSize ?? '12') }]}>{subTitle.text}<br />这里组件中的文字大小都是一致的，不支持在富文本中设置字体大小。

按钮部分除了按钮文案、按钮渐变色可配置外，还有一点要注意的是按钮大小需要由文字撑开，这样才能在改变按钮文案字数时保证样式不呲。

buttonView: {<br />height: 28,<br />minWidth: 52,	// 设个最小宽度<br />display: 'flex',<br />alignItems: 'center',<br />justifyContent: 'center',<br />borderRadius: 16,<br />paddingHorizontal: 10,<br />paddingVertical: 4<br />}

关于组件交互上的复用性，在设计时遵循迪米特法则，让此组件只关注自己需要关注的部分。<br />由于此组件可能会在多个业务需求中使用，那么组件的埋点一定不是通用的，需要抽取出来按不同业务需求分别定义，同时不同需求中按钮的点击事件可能不同，需要抽取出来。但是组件的关闭按钮点击事件，各业务需求都相同，直接定义在组件内部即可。

// 关闭订阅视图<br />closeView = () => {<br />Animated.timing(this.slideAnimation, {<br />toValue: 0,<br />duration: 300,<br />easing: Easing.linear,<br />useNativeDriver: true,<br />}).start(() => {<br />// 浮窗只展示一次，重新请求数据后再展示；写在回调里，等动画执行完再改变observer的值，不然直接render会打断动画执行。<br />this.setState({<br />isTimeout: true<br />})<br />this.props.afterClose?.();	// 这块加一个回调函数，是因为组件关闭后可能会有些要做的事，比如由后端做频控的话可在此调后端接口通知后端。<br />});<br />};<br />render() {<br />if (this.state.isTimeout) {<br />return null<br />}<br />}

5. 业务逻辑<br />伊海迪 > 2023-12-19：低价订阅需求分享 > image-2023-12-17_21-38-46.png

伊海迪 > 2023-12-19：低价订阅需求分享 > image-2023-12-17_21-39-14.png

首先浮窗组件有一些比较好想到的的出现和消失逻辑，如图。

除了图中的逻辑外，还有些隐藏的逻辑需要考虑：

首先浮窗出现的时机，不能在进入list页时，就让浮窗出现，需要在数据请求回来后再让浮窗组件出现，在网络请求模块中有一个indicator属性，该属性可以用于判断网络请求的状态，通过该属性控制浮窗组件在数据回来后再出现。

其次是组件消失的时机，在list页切换日期时浮窗是需要消失的，切换日期后满足条件再出现。判断组件呼吸同样可以用indicator属性。

SingleSearchStore中通过reaction方法监测indicator的变化，当status为FetchStatus.Loading时，让浮窗消失。

```
setupStore = reaction(
    () => {
        return this.netWorkModel ? this.netWorkModel.airlinesState.indicator : null;
    },
    (indicator) => {
        if (!indicator) {
            return;
        }
        const { status, result, error, searchFrom, serviceType, param } = indicator;
        if (status === FetchStatus.Loading || !status) {
            // list页请求接口进入loading时，让底部提示条立刻消失
            this.lowPriceRemindModel?.changeLoadingState()
            return;
        }
})
```

在LowPriceRemindModel中使用reaction方法监测reqParam（包含日期、城市）是否发生变化，日期或城市变化需要去请求降价提醒的接口，看当前航线是否被订阅，在此已经拿到了list页的数据，可以把Loading状态置为false。

```
/**
 * 监听日期、城市
 * 当发生变化时，请求降价提醒的网络请求
 */
updateReserveCount = reaction(
    () => {
        const reqParam = this.rootStore ? this.rootStore!.param!.reqParam : null;
        if (reqParam) {
            const { goDate, depCity, arrCity, routeType } = reqParam;
            if (routeType === RouteType.FUZZY_RANGE_NONE) {
                const object = {
                    goDate,
                    depCity,
                    arrCity
                };
                return JSON.stringify(object);
            }
        }
        return null;
    },
    object => {
        if (!object) {
            return;
        }
        this.requestReserveCount(this.reqParam)
    }
);


/**
 * 降价提醒的网络请求
 * 请求时机
 * 1、页面活页的时候 已有
 * 2、当日期、城市发生变化的时候
 */
@action.bound async requestReserveCount(param: SearchReqParam) {
    let result = await fetchReserveCount({ context: this.rootStore!, reqParam: param });
    runInAction(() => {
        const { bstatus } = result || {};
        const { code } = bstatus || {};
        // 当成功的时候，才保存结果
        if (code === 0) {
            this.remindResult = result;
            const { status } = this.rootStore.netWorkModel?.airlinesState.indicator || {};
            if (status === FetchStatus.Loading || !status) {
                this.isLoading = true
            } else {
                this.isLoading = false
            }

        }
    });
    this.rootStore!.reserveGuideModel!.diffShowGuideView();
}
```

伊海迪 > 2023-12-19：低价订阅需求分享 > image-2023-12-17_21-39-57.png

浮窗的展示条件：由于主站感知不到list页右上角订阅入口的状态，所以有可能此日期航班已经被订阅了，主站还给返浮窗提示条的数据，那么就不能仅仅根据主站是否返提示条数据来控制浮窗是否出现了。通过总结，浮窗可出现的条件为：当前航线未被订阅且为提示订阅文案 || 当前航线已被订阅且为订阅成功文案 || 当前航线已被订阅且为订阅失败文案。也就是说只有当前航线已被订阅且提示条文案为提示订阅文案时，浮窗组件才不展示。

(!(bottomViewState === 0 && hasSubscribe) && !isLoading && bottomTip && tipId === types?.SUBSCRIBE && isLogin)
